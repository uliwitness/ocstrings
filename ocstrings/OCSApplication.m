//
//  OCSApplication.m
//  ocstrings
//
//  Created by Uli Kusterer on 27.07.17.
//  Copyright Â© 2017 Uli Kusterer. All rights reserved.
//

#import "OCSApplication.h"

@implementation OCSApplication

-(NSString*) unescapeStringAndMakeIdentifier: (NSString*)keyString
{
	keyString = [keyString stringByReplacingOccurrencesOfString: @" " withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @"," withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @"." withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @":" withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @"\\\"" withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @"\\r" withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @"\\n" withString: @"_"];
	keyString = [keyString stringByReplacingOccurrencesOfString: @"\\\\" withString: @"_"];
	while ([keyString rangeOfString: @"__"].location != NSNotFound) {
		keyString = [keyString stringByReplacingOccurrencesOfString: @"__" withString: @"_"];
	}
	return keyString;
}


-(void) extractParamsFromFormatString: (NSString*)valString intoParams: (NSString**)outParamsStr paramNames: (NSString**)outParamNamesStr template: (NSDictionary<NSString*,id>*)template
{
	NSError * err = nil;
	NSMutableString * paramsStr = [NSMutableString string];
	NSMutableString * paramNamesStr = [NSMutableString string];
	NSDictionary<NSString*,NSString*>* typesForFormats = template[@"types-for-formats"];
	
	NSRegularExpression * regEx = [NSRegularExpression regularExpressionWithPattern: @"%(([0-9]+)[$])*([0-9]+)*(\\.([0-9]+))*([l]*[aAcCpnsxXdufFgGoieE@])" options: 0 error: &err];
	if( !regEx ) {
		NSLog(@"Couldn't parse format regex %@", err);
		return;
	}
	
	NSInteger x = 1;
	BOOL isFirst = YES;
	NSArray<NSTextCheckingResult*>* matches = [regEx matchesInString: valString options:0 range:(NSRange){0,valString.length}];
	for (NSTextCheckingResult * match in matches) {
		NSRange positionRange = [match rangeAtIndex: 2];
		NSString * positionStr = (positionRange.location != NSNotFound) ? [valString substringWithRange: positionRange] : nil;
		if (positionStr) x = positionStr.integerValue;
//		NSRange widthRange = [match rangeAtIndex: 3];
//		NSString * widthStr = (widthRange.location != NSNotFound) ? [valString substringWithRange: widthRange] : nil;
//		NSRange precisionRange = [match rangeAtIndex: 5];
//		NSString * precisionStr = (precisionRange.location != NSNotFound) ? [valString substringWithRange: precisionRange] : nil;
		NSRange lengthAndSpecifierRange = [match rangeAtIndex: 6];
		NSString * lengthAndSpecifierStr = (lengthAndSpecifierRange.location != NSNotFound) ? [valString substringWithRange: lengthAndSpecifierRange] : nil;
		
		NSString * typeForFormat = typesForFormats[lengthAndSpecifierStr];
		if (!typeForFormat) typeForFormat = template[@"parameter-any-type"];
		
		[paramsStr appendFormat: template[isFirst ? @"parameter-first" : @"parameter"], typeForFormat, x];
		[paramNamesStr appendFormat: template[isFirst ? @"parameter-name-first" : @"parameter-name"], x];
		
		isFirst = NO;
		++x;
	}
	
	*outParamsStr = paramsStr;
	*outParamNamesStr = paramNamesStr;
}


-(NSDictionary<NSString*,id>*) templateNamed: (NSString*)inTemplateName
{
	if (!inTemplateName)
		inTemplateName = @"swift";
	static NSDictionary<NSString*,NSDictionary<NSString*,id>*>* sTemplates = nil;
	if (!sTemplates) {
		sTemplates = @{
					   @"objective-c": @{
							   @"source-filename-suffix": @"Strings.m",
							   @"header-filename-suffix": @"Strings.h",
							   @"header-prelude": @"// This file was autogenerated from the %1$@.strings file by ocstrings.\n// Do not edit this file, edit the strings file and then re-generate this file based on it.\n\n#import <Foundation/Foundation.h>\n\n@interface %2$@Strings : NSObject\n",
							   @"source-prelude": @"// This file was autogenerated from the %1$@.strings file by ocstrings.\n// Do not edit this file, edit the strings file and then re-generate this file based on it.\n\n#import \"%2$@Strings.h\"\n\n@implementation %2$@Strings\n\n",
							   @"header-parameterized-method": @"+ (NSString*)%2$@%1$@;",
							   @"source-parameterized-method": @"+ (NSString*)%2$@%1$@\n{\n\treturn [NSString stringWithFormat: NSLocalizedStringFromTable(@\"%3$@\", @\"%4$@\", @\"%5$@\"), %6$@];\n}\n\n",
							   @"header-method": @"+ (NSString*)%1$@;",
							   @"source-method": @"+ (NSString*)%1$@\n{\n\treturn NSLocalizedStringFromTable(@\"%2$@\", @\"%3$@\", @\"%4$@\");\n}\n\n",
							   @"parameter": @" : (%1$@)arg%2$ld",
							   @"parameter-first": @": (%1$@)arg%2$ld",
							   @"parameter-name-first": @"arg%1$ld",
							   @"parameter-name": @", arg%1$ld",
							   @"header-postlude": @"\n@end\n",
							   @"source-postlude": @"@end\n",
							   @"parameter-any-type": @"id",
							   @"types-for-formats": @{ @"d": @"int",
														@"u": @"unsigned int",
														@"x": @"unsigned int",
														@"X": @"unsigned int",
														@"o": @"unsigned int",
														@"ld": @"long",
														@"lu": @"unsigned long",
														@"lx": @"unsigned long",
														@"lX": @"unsigned long",
														@"lo": @"unsigned long",
														@"lld": @"long long",
														@"llu": @"unsigned long long",
														@"llx": @"unsigned long long",
														@"llX": @"unsigned long long",
														@"llo": @"unsigned long long",
														@"f": @"double",
														@"F": @"double",
														@"e": @"double",
														@"E": @"double",
														@"g": @"double",
														@"G": @"double",
														@"a": @"double",
														@"A": @"double",
														@"c": @"char",
														@"C": @"unichar",
														@"p": @"void*",
														@"s": @"char*",
														@"n": @"int*"}
							   },
					   @"swift": @{
							   @"source-filename-suffix": @"Strings.swift",
							   @"source-prelude": @"// This file was autogenerated from the %1$@.strings file by ocstrings.\n// Do not edit this file, edit the strings file and then re-generate this file based on it.\n\nimport Foundation\n\nclass %2$@Strings {\n",
							   @"source-parameterized-method": @"    public static func %2$@(%1$@) -> String {\n        return String(format: NSLocalizedString(\"%3$@\", tableName: \"%4$@\", comment: \"%5$@\"), arguments: [%6$@])\n    }\n\n",
							   @"source-method": @"    public static var %1$@: String {\n        return NSLocalizedString(\"%2$@\", tableName: \"%3$@\", comment: \"%4$@\")\n    }\n\n",
							   @"source-postlude": @"}\n",
							   @"parameter": @", _ arg%2$ld: %1$@",
							   @"parameter-first": @"_ arg%2$ld: %1$@",
							   @"parameter-name-first": @"arg%1$ld",
							   @"parameter-name": @", arg%1$ld",
							   @"parameter-any-type": @"CVarArg",
							   @"types-for-formats": @{ @"d": @"Int32",
														@"u": @"UInt32",
														@"x": @"UInt32",
														@"X": @"UInt32",
														@"o": @"UInt32",
														@"ld": @"Int",
														@"lu": @"UInt",
														@"lx": @"UInt",
														@"lX": @"UInt",
														@"lo": @"UInt",
														@"lld": @"Int64",
														@"llu": @"UInt64",
														@"llx": @"UInt64",
														@"llX": @"UInt64",
														@"llo": @"UInt64",
														@"f": @"Double",
														@"F": @"Double",
														@"e": @"Double",
														@"E": @"Double",
														@"g": @"Double",
														@"G": @"Double",
														@"a": @"Double",
														@"A": @"Double",
														@"c": @"Int8",
														@"C": @"Int16"}
							   }
					   };
	}
	return sTemplates[inTemplateName.lowercaseString];
}


-(BOOL) openFile:(NSString *)filePath
{
	NSError * err = nil;
	NSString * stringsStr = [NSString stringWithContentsOfFile: filePath encoding:NSUTF8StringEncoding error: &err];
	if (!stringsStr) {
		NSLog(@"Couldn't open file \"%@\": %@", filePath, err);
		return NO;
	}
	
	NSDictionary<NSString*,id>* template = [self templateNamed: [[NSUserDefaults standardUserDefaults] objectForKey: @"-language"]];

	// Build output file paths:
	NSString * basePath = [filePath.lastPathComponent stringByDeletingPathExtension];
	NSString * classPrefix = [[NSUserDefaults standardUserDefaults] objectForKey: @"-class-prefix"];
	if (classPrefix) {
		basePath = [[basePath stringByDeletingLastPathComponent] stringByAppendingPathComponent: [classPrefix stringByAppendingString: [basePath lastPathComponent]]];
	} else {
		classPrefix = @"";
	}
	NSString * headerPath = nil;
	NSString * headerSuffix = template[@"header-filename-suffix"];
	if (headerSuffix) {
		headerPath = [basePath stringByAppendingString: headerSuffix];
	}
	NSString * sourcePath = nil;
	NSString * sourceSuffix = template[@"source-filename-suffix"];
	if (sourceSuffix) {
		sourcePath = [basePath stringByAppendingString: sourceSuffix];
	}
	
	// Temp storage for generated code:
	NSMutableString * stringsHeaderContents = headerPath ? [NSMutableString string] : nil;
	NSMutableString * stringsSourceContents = [NSMutableString string];
	
	NSString * tableName = filePath.lastPathComponent.stringByDeletingPathExtension;
	NSString * generatedClassName = [classPrefix stringByAppendingString: tableName];
	
	[stringsHeaderContents appendFormat: template[@"header-prelude"], tableName, generatedClassName];
	[stringsSourceContents appendFormat: template[@"source-prelude"], tableName, generatedClassName];
	
	NSScanner * scanner = [NSScanner scannerWithString: stringsStr];
	scanner.charactersToBeSkipped = nil;
	NSCharacterSet * wsCS = [NSCharacterSet whitespaceCharacterSet];
	
	while (!scanner.atEnd) {
		NSString * inbetweenStr = nil;
		[scanner scanUpToString: @"\"" intoString: &inbetweenStr];
		if (inbetweenStr) {
			[stringsHeaderContents appendString: inbetweenStr];
		}
		[scanner scanString: @"\"" intoString: nil];
		
		// Parse key:
		NSMutableString * keyString = [NSMutableString string];
		BOOL keyIsDone = NO;
		while (!scanner.atEnd && !keyIsDone) {
			NSString * keyPart = nil;
			[scanner scanUpToString: @"\"" intoString: &keyPart];
			if (keyPart) {
				[keyString appendString: keyPart];
			}
			if (![keyPart hasSuffix: @"\\"]) {
				keyIsDone = YES;
				[scanner scanString: @"\"" intoString: nil];
			} else {
				[scanner scanString: @"\"" intoString: &keyPart];
				if (keyPart) {
					[keyString appendString: keyPart];
				}
			}
		}
		
		// Parse equals sign:
		[scanner scanCharactersFromSet: wsCS intoString: nil];
		[scanner scanString: @"=" intoString: nil];
		[scanner scanCharactersFromSet: wsCS intoString: nil];
		[scanner scanString: @"\"" intoString: nil];

		// Parse value:
		NSMutableString * valString = [NSMutableString string];
		BOOL valIsDone = NO;
		while (!scanner.atEnd && !valIsDone) {
			NSString * valPart = nil;
			[scanner scanUpToString: @"\"" intoString: &valPart];
			if (valPart) {
				[valString appendString: valPart];
			}
			if (![valPart hasSuffix: @"\\"]) {
				valIsDone = YES;
				[scanner scanString: @"\"" intoString: nil];
			} else {
				[scanner scanString: @"\"" intoString: &valPart];
				if (valPart) {
					[valString appendString: valPart];
				}
			}
		}

		[scanner scanCharactersFromSet: wsCS intoString: nil];
		[scanner scanString: @";" intoString: nil];
		[scanner scanCharactersFromSet: wsCS intoString: nil];

		// Generate code for this pair:
		NSString * paramsStr = nil;
		NSString * paramNamesStr = nil;
		[self extractParamsFromFormatString: valString intoParams: &paramsStr paramNames: &paramNamesStr template: template];
		NSString * keyAsIdentifier = [self unescapeStringAndMakeIdentifier: keyString];
		if (paramsStr.length > 0) {
			[stringsHeaderContents appendFormat: template[@"header-parameterized-method"], paramsStr, keyAsIdentifier];
			[stringsSourceContents appendFormat: template[@"source-parameterized-method"], paramsStr, keyAsIdentifier, keyString, tableName, valString, paramNamesStr];
		} else {
			[stringsHeaderContents appendFormat: template[@"header-method"], keyAsIdentifier];
			[stringsSourceContents appendFormat: template[@"source-method"], keyAsIdentifier, keyString, tableName, valString];
		}
		
		[scanner scanUpToString: @"\"" intoString: &inbetweenStr];
		if (inbetweenStr) {
			[stringsHeaderContents appendString: inbetweenStr];
		}
	}

	[stringsHeaderContents appendString: template[@"header-postlude"]];
	[stringsSourceContents appendString: template[@"source-postlude"]];
	
	// Write out:
	if (headerPath && ![stringsHeaderContents writeToFile: headerPath atomically: YES encoding: NSUTF8StringEncoding error: &err]) {
		NSLog(@"Couldn't write header: %@", err);
		return NO;
	}
	if (sourcePath && ![stringsSourceContents writeToFile: sourcePath atomically: YES encoding: NSUTF8StringEncoding error: &err]) {
		NSLog(@"Couldn't write sources: %@", err);
		return NO;
	}
	return YES;
}

@end
